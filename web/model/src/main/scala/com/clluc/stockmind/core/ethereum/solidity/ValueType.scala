package com.clluc.stockmind.core.ethereum.solidity

import com.clluc.stockmind.core.ethereum.solidity.ValueEncodingDefinition.EncodingDefinition

import scala.util.Try

// TODO Really unsure that is a good idea to introduce disruptive side effects like this one in a case class constructor
// The compiler is not warning us of what can happen. This in some way re-introduces the Java NullPointerException issue in an Scala application.
// Proposed solution: Use an error safe interpretation (Either or Option should suffice); and wrap the constructor in
// a custom factory (apply) method that returns that safe interpretation
// It happens in a lot of data structures contained in this ADT.
private[ethereum] sealed trait ValueType {
  def encode: String
  def asBlocks: EncodingDefinition
  def canonical: String
  protected def paddedLeftZero(value: String)  = "0" * (64 - value.length) + value
  protected def paddedRightZero(value: String) = value + "0" * (64 - value.length)
}

private[solidity] sealed trait StaticType extends ValueType {
  override def asBlocks: EncodingDefinition = Left(ParamBlock(encode))
}

private[solidity] sealed trait DynamicType extends ValueType {
  // This means different things depending on the type: size in bytes for
  // strings, number of elements for arrays.
  def size: Int

  override def asBlocks: EncodingDefinition = {
    val header        = Uint(256, size).asBlocks.left.get
    val encodedValues = encode.grouped(64).toList
    val initBlocks    = encodedValues.init.map(ParamBlock.apply)
    val lastBlock     = ParamBlock(paddedRightZero(encodedValues.last))
    Right((header :: initBlocks) :+ lastBlock)
  }
}

case class Uint(bits: Int = 256, value: BigInt) extends StaticType {
  require(bits > 0, "bits must be greater than 0")
  require(bits <= 256, "bits must be lower than 256")
  require(bits % 8 == 0, "bits must be divisor of 8")
  private val maxValue = BigInt("2").pow(bits)
  require(value <= maxValue, s"value must be lower than $maxValue")
  require(value >= 0, "value must be positive")

  override def encode    = paddedLeftZero(value.toString(16))
  override def canonical = "uint" + bits
}

object Uint {
  def apply(bits: Int): Uint                 = Uint(bits, 0)
  def decode(bits: Int, notPrefixed: String) = Uint(bits, BigInt(notPrefixed, 16))
}

private[solidity] case class Bytes(bytes: Int, value: String) extends StaticType {
  private val addressPattern = """[a-f0-9]*"""
  require(value.toLowerCase.matches(addressPattern), "value is not a hex string")
  require(bytes <= 32 && bytes > 0, "size must be between 1 and 32")
  require((bytes * 2) >= value.length, "value length exceeds bytes size")

  override def encode    = paddedRightZero(value.toLowerCase)
  override def canonical = "bytes" + bytes

  def leftPadded = {
    val paddedValue = paddedLeftZero(value).takeRight(bytes * 2)
    Bytes(bytes, paddedValue)
  }
}

private[solidity] object Bytes {

  def apply(bits: Int): Bytes = Bytes(bits, "")

  def stringAsAscii(bytes: Int, s: String) = {
    val ascii = s.map(_.toInt.toHexString).mkString
    Bytes(bytes, ascii)
  }

}

private[solidity] case class Bool(value: Boolean) extends StaticType {
  override def encode = value match {
    case true  => paddedLeftZero("1")
    case false => paddedLeftZero("0")
  }
  override val canonical = "bool"
}

private[solidity] object Bool {
  def apply: Bool                    = Bool(false)
  def decode(prefixedWith0x: String) = Bool(prefixedWith0x.contains('1'))
}

// As this is part of a port contract, it must be public
case class Address(value: String) extends StaticType {
  private val addressPattern = """[a-f0-9]{40}"""

  require(value.matches(addressPattern),
          s"An address should stick to the pattern $addressPattern (was $value)")

  override def encode: String = paddedLeftZero(value)
  override val canonical      = "address"

  def toHex = s"0x$value"
}

object Address {
  // Renamed this one due to the collision with the apply method generated by the case class
  // That was giving some trouble to the compiler for some reason (at least some trouble to me)
  lazy val default: Address = Address("0" * 40)

  def decode(prefixedWith0x: String) = Address(prefixedWith0x.takeRight(40).toLowerCase)
}

case class SolidityString(value: String) extends DynamicType {
  override val canonical: String = "string"
  override def size: Int         = value.getBytes("UTF-8").length
  override def encode: String = {
    value
      .getBytes("UTF-8")
      .map(_.toInt.toHexString.takeRight(2))
      .mkString
  }
}

object SolidityString {

  def decode(notPrefixed: String) = {
    val byteArray = notPrefixed
      .grouped(2)
      .toList
      .map(h => Integer.parseInt(h, 16).toByte)
      .toArray
    new String(byteArray, "UTF-8")
  }

  /**
    * Decode an ABI-encoded string into a UTF-8 string.
    * @param string The string. Note that you cannot pass a whole encode result as-is. You need to
    *               pass only the chunks that relate to the string, that is, the length header and
    *               the chunks containing the string data.
    * @return The decoded string, or None if the string cannot be decoded.
    */
  def decodeDynamicEncoded(string: String): Option[String] = {
    // This first implementation will limit the size of the strings to a single chunk.
    // TODO add support for decoding longer strings

    if (string.length != 128) { // Input string must contain exactly 2 chunks
      None
    } else {
      val (firstChunk, secondChunk) = string.splitAt(64)
      val strLength                 = Integer.parseInt(firstChunk, 16)
      val (strData, padding)        = secondChunk.splitAt(strLength * 2)
      if (padding.exists(_ != '0')) { // The part of the string that is supposed to be empty should be empty
        None
      } else {
        Try(decode(strData)).toOption
      }
    }
  }
}
